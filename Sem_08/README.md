# Динамично програмиране

### Задача 1:
Студент се намира пред стълба с n стъпала. Той се изкачва по стълбата, като на всяка крачка взима или по едно, или по две стъпала. Съставете бърз алгоритъм, който пресмята по колко начина студентът може да се изкачи по стълбата.

### Решение (fibonacci.cpp (recursive/memoization/DP)):
Нека X_n е броят на начините за изкачване на стълба с n стъпала. Лесно се вижда, че X_1 = 1, X_2 = 2. С последната крачка студентът изкачва или едно, или две стъпала. Ето защо X_k = X_{k−1} + X_{k−2}, k ≥ 3. Чрез това уравнение пресмятаме X_k за k от 3 до n и връщаме X_n (получават се **числа на Фибоначи**). Този алгоритъм има **времева сложност O(n)**.  

### Memoization
![alt_text](https://i.ibb.co/rdn7x4x/FibMem.png)

### Dynamic programming
![alt_text](https://i.ibb.co/XYpz54P/FibDP.png)

### Задача 2:
Крадец влиза в картинна галерия с n картини с цени съответно a_1, a_2, .., a_n лева. Картините са подредени последователно и крадецът знае за повреда в алармената система, която се активира, ако бъдат откраднати две съседни картини, но не се активира, ако бъде открадната картина, без да се пипат съседните.
1. Предложете бърз алгоритъм, **изчисляващ цената на най-скъпата колекция, която крадецът може да отмъкне безнаказано**.
2. Разширете алгоритъма така, че **да изчисли кои картини да вземе крадецът**.

### Решение (Task02.cpp):
**Идея на алгоритъма:** При изчисляването на maxProfits[k] има две възможности: крадецът да вземе или да не вземе k-тата картина. Ако той реши да не вземе k-тата картина, тогава максималната му печалба е колкото от първите k-1 картини, т.е. maxProfits[k-1]. Ако крадецът вземе k-тата картина, то максималната му печалба е колкото от първите k-2 картини, т.е. maxProfits[k-2], плюс стойността на k-тата картина, т.е. paintingsPrices[k]. Тук имаме k-2, а не k-1, тъй като, щом крадецът е решил да вземе k-тата картина, той трябва да се откаже от (k-1)-та.  

Количеството допълнителна памет, използвано от алгоритъма, може да се оптимизира:  
елементите на масива maxProfits не са нужни през цялото време на изпълнение на алгоритъма;  
достатъчно е да пазим три последователни елемента, а именно maxProfits[k-2], maxProfits[k-1], maxProfits[k]. Това **намалява на порядък сложността по памет**.

---

### Задача 3:
Дадени са три масива A[1..n], B[1..n] и C[1..n].  
Предложете алгоритъм, който **намира най- голямата стойност на сума от n събираеми**, която може да се образува като се спазват следните правила:
1. k-тото събираемо е A[k], B[k] или C[k];
2. не може да има поредни събираеми от един и същи масив (ако например k-тото събираемо е A[k], то (k+1)-то събираемо е или B[k+1], или C[k+1], но не и A[k+1]).  

Алгоритъмът да работи за **време O(n)** и **памет O(n)**.  
**Оптимизирайте паметта до константен брой променливи** от целочислен тип.

### Решение (Task03.cpp):
**Демонстрация на алгоритъма** при:  
A = { 2, 3, 5, 1, 8, 7, 6 };  
B = { 6, 9, 8, 0, 5, 9, 7 };  
C = { 4, 1, 2, 8, 4, 2, 5 }:  
	
![alt_text](https://i.ibb.co/nCNr7Zn/DP.png)

---

### Задача 4:
Да се намери броя на наредените n-орки (x_1, x_2, .., x_n), състоящи се от цели неотрицателни числа, които са решения на уравнението A_1\*x_1 + A_2\*x_2 + ... + A_n\*x_n = B, по дадени цели положителни числа A_1, A_2, .., A_n и B.  
Предложете итеративен алгоритъм, който работи за **време O(n\*B)** и **памет O(n\*B)**.

### Решение (Task04.cpp):
**Демонстрация на алгоритъма** при:  
A = { 2, 3, 5 };  
B = 9:  

![alt_text](https://i.ibb.co/tLGmKLS/DP-2.png)
