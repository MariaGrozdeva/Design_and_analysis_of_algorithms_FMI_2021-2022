# Нетегловни графи

### Задача 1:
Няколко банки си дължат взаимно разни суми. Съставете бърз алгоритъм, който да провери **има ли възможност за прихващане между две или повече банки**.

### Решение:
Представяме входните данни чрез ориентиран граф.  
**Върховете на графа съответстват на банките**, а **ребрата - на задълженията**.  
По-точно, ако банката U има задължение към банката V, ще има ребро от U към V, тоест U —> V.  
Всяко прихващане съответства на ориентиран цикъл в графа.  
**Търсим ориентиран цикъл с помощта на обхождане в дълбочина**.  
Този алгоритъм изразходва време O(m + n), където n е броят на банките (върховете на графа), а m - броят на задълженията между банките (тоест ребрата на графа).

### Задача 2:
Да се състави алгоритъм, който проверява **дали дадена схема от зъбчати колела може да работи**. (Някои колела се допират и така предават движението си едно на друго.)

### Решение:
Моделираме входните данни чрез неориентиран граф.  
**Върховете на графа съответстват на зъбчатите колела**, а **ребрата - на зацепванията**. Тоест между върховете А и В има ребро <=> колелата А и В се зацепват.  
Схемата ще работи <=> в графа няма цикъл с нечетна дължина.  

**Теорема на Кьониг: един неориентиран граф е двуделен <=> не съдържа цикли с нечетна дължина.**  

Следователно схемата ще работи <=> **графът е двуделен <=> върховете (колелата) могат да се оцветят в два цвята**, съответстващи на посоките на въртене - цвят "по часовника" и цвят "срещу часовника". (Не е важно, ако това може да стане поне по два начина: един начин и неговият негатив.)

### Задача 3:
Върху куфара на един турист има лепенки от различни градове, които туристът е посетил. Някои лепенки се припокриват частично, тоест може да се случи лепенката А да е поставена върху лепенката В.  
Съставете алгоритъм, който **намира реда на посещаване на градовете** (тоест реда на поставяне на лепенките върху куфара). Естествено, този ред може да не е определен еднозначно; в такъв случай да се изведе един възможен ред.

### Решение:
Използваме ориентиран граф, чиито **върхове съответстват на лепенките**, а **ребрата - на припокриванията на лепенките**.  
Ако лепенката В е поставена върху лепенката А, то градът В е посетен след града А, затова слагаме ребро от А към В, тоест А —> В.  
Трябва да подредим лепенките (градовете) така, че ребрата да сочат само от ляво надясно. **Това става с помощта на топологично сортиране**, а то използва обхождане в дълбочина.  
Времето на алгоритъма е линейно: O(m + n), където n = броя на лепенките (върховете на графа), m = броя на припокриванията (ребрата на графа).  

![alt_text](https://i.ibb.co/TtGhH5B/topoSort.png)

### Задача 4:
В някакъв форум сме попаднали на обяви от вида:
- "Заменям велосипед за чифт ски.";
- "Заменям третия том на 'Винету' за втория том на същата книга.";
- "Заменям чисто нов компютър за пълен комплект лекции по ДАА."

и други подобни.  
Ние самите имаме ненужен предмет X, а ни трябва предмет Y. За съжаление, във форума липсва обява "Заменям Y за X." Обаче може да има начин да постигнем целта си с няколко замени. Естествено, искаме замените да са възможно най-малко: всяка замяна струва преговори, срещи, време...  
Съставете бърз алгоритъм, който **да ни помогне да получим Y срещу X с възможно най-малко замени**.

### Решение:
Представяме входните данни чрез ориентиран граф.  
**Върховете на графа съответстват на предметите** (томовете на "Винету", велосипеда, ските, компютъра, записките по ДАА и т.н.). **Ребрата на графа съответстват на обявите**. По-точно, обявата " Заменям предмета U за предмета V." се представя така: V —> U.  
Графът съдържа два специални върха X и Y (съответно предмета, който имаме, и предмета, който търсим). Всяка редица от замени е път в графа. Търсим най-къса редица от замени, тоест **най-къс път от X до Y**.  
За целта използваме **търсене в ширина**. Този алгоритъм решава задачата за време O(m + n), където n е броят на предметите (върховете), m - броят на обявите (ребрата).

### Задача 5:
Даден е списък от "връзки" между учебни предмети:  
"За да учим диференциална геометрия, трябва преди това да сме учили математически анализ и аналитична геометрия." и други подобни.  
Съставете бърз алгоритъм, който ни казва **как да се подредят предметите в учебния план на студентите**.

### Решение:
Представяме входните данни чрез ориентиран граф.  
**Върховете на графа съответстват на предметите**, а **ребрата - на връзките**. Посока на ребрата е от по-ранен към по-късен предмет. По-точно, връзката "За да учим предмет X, трябва преди това да сме учили предмети Y и Z." се представя така: Y —> X и Z —> X.  
Задачата се решава чрез **топологично сортиране на графа**.

### Задача 6:
Експертна система съдържа теореми от тип импликации между разни свойства (твърдения), например:  
- "Ако едно число се дели на 6, то се дели на 3.";
- "Ако едно число е точен квадрат, то не може да бъде просто."

и така нататък.  

Да се състави бърз алгоритъм, който **по дадена съвкупност от теореми разделя свойствата на групи от еквивалентни свойства**, например:  
"едно число завършва на нула" <=> "числото се дели на 10" <=> "числото се дели на 2 и на 5 ".  
Друга група:  
"едно естествено число е точен квадрат" <=> "в разлагането му на прости множители всички степенни показатели са четни" <=> "квадратният му корен е цяло число".

### Решение:
Моделираме условието на задачата с ориентиран граф.  
**Върховете на графа представляват отделните свойства**, а **ребрата - връзките между тях, изразени чрез теоремите**. Посоките на ребрата съответстват на посоките на импликациите, тоест теорема "Ако U, то V." се представя чрез реброто U —> V.  
Две свойства P и Q са равносилни, ако от P следва Q и от Q следва P за една или повече стъпки, тоест ако има път както от P до Q, така и от Q до P. С други думи, две свойства са равносилни <=>  
**съответните им върхове в графа са силно свързани**.  

Затова групите от еквивалентни свойства съответстват на **компонентите на силна свързаност**.  
Намираме ги чрез обхождане в дълбочина за време O(m + n), където n е броят на свойствата (върховете на графа), а m - броят на дадените теореми (ребрата на графа).  

![alt_text](https://i.ibb.co/BcYMCmw/SCC.png)

### Задача 7:
За голяма група от хора имаме информация от типа:  
"X казва на Y всяка новина, която узнае."  
Научили сме някаква новина, но имаме право само на един разговор. Съставете бърз алгоритъм, който ни **връща на кого от групата да кажем новината, за да я научат всички** (Може и да няма такъв човек.)

### Решение:
Моделираме задачата с ориентиран граф.  
**Върховете на графа са хората от групата**; **има ребро от X към Y <=> X казва на Y всяка новина, която узнае**.  

***Първи случай: графът е ацикличен***.  
Извършваме **топологично сортиране**.  
Ако изобщо има връх с желаното свойство, то това е първият връх в получения списък. Дали всички върхове са достижими от първия,  
разбираме с помощта на ново обхождане (BFS/DFS). Ако всички са достижими - първият връх е решение. Ако не всички са достижими - няма такъв връх (човек).  

***Втори случай: графът съдържа цикъл***.  
Сега не можем да извършим топологично сортиране. Обаче върховете от една и съща компонента на силна свързаност едновременно имат или нямат желаното свойство; а също научават или не научават новината.  

Затова **намираме компонентите на силна свързаност**.  Построяваме граф, съставен от тях (тоест върховете на новия граф  
са компонентите на силна свързаност на стария граф).  
Прилагаме алгоритъма от първи случай за новия граф.  
Задачата има решение за стария граф <=> приложеният алгоритъм ни върне, че има решение на новия. Върхът от новия граф, който е решение, ако има такъв, съответства на една компонента на силна свързаност на стария граф. Който и да е връх от тази компонента на силна свързаност има желаното свойство, тоест можем да съобщим новината на произволен човек от тази компонента на силна свързаност.
