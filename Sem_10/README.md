## Алгортими върху тегловни графи
- Dijkstra's algorithm
- Bellman–Ford
- Floyd–Warshall
- Prim's algorithm
- Kruskal's algorithm

## Задачи
### Задача 1:
Някои от компютрите в дадена мрежа са свързани с ненадеждни връзки: поради шума съобщенията могат да бъдат предадени грешно. За всяка връзка между два компютъра е дадена нейната надеждност: число между 0 и 1, показващо вероятността за правилно предаване на съобщение. За два дадени компютъра s и t **да се определи най-надеждният път между тях**.

### Решение:
Разглеждаме граф, чиито **върхове са компютрите**, **ребрата са връзките между компютрите**, а **теглата на ребрата са надеждностите на връзките**.  
Използваме **алгоритъма на Дейкстра**.  
Неговата времева сложност е 	O(m + n)*lgn при най-лоши входни данни, ако използваме приоритетна опашка, реализирана чрез пирамида на Фибоначи.  
  
Директно прилагане на алгоритъма на Дейкстра не ни върши работа, защото дължината на път = сбора от дължините на ребрата, а надеждностите се умножават, вместо да се събират!  

Пример: ако едно съобщение се предава два пъти, първия път - с надеждност 90%, а втория път - с надеждност 80%, то в крайна сметка общата надеждност е 0.8 * 0.9 = 0.72 = 72%.  

За да заменим умножението със събиране, логаритмуваме надеждностите при произволна (но една и съща) основа > 1, например при основа e.  

Възникват два проблема:
- алгоритъмът на Дейкстра работи само с неотрицателни тегла,  
а логаритмите на числа между 0 и 1 са отрицателни;
- алгоритъмът на Дейкстра търси най-къс път, т.е. дължина = min, а ние търсим най-надежден път, т.е. надеждност = max <=> ln(надеждност) = max.

Двата проблема се решават едновременно: сменяме знаците на логаритмите. Тоест обхождаме графа и всяка надеждност p заменяме с –ln p. След това прилагаме алгоритъма на Дейкстра. Първоначалното обхождане е с линейна времева сложност, която е пренебрежимо малка спрямо времето на алгоритъма на Дейкстра.  
  
( Вместо първо да логаритмуваме при основа A > 1, а после да сменяме знака, можем направо да логаритмуваме при основа 1/A < 1. )

---

### Задача 2:
Знаем курсовете за обмен между различни двойки валути. Искаме да "завъртим" някакво количество от някаква валута S така, че накрая да имаме по-голямо количество от същата валута.  
Съставете бърз алгоритъм, който проверява дали това е възможно:  
- ако валутата S е точно определена (тоест отначало разполагаме само с нея);
- ако валутата S не е дадена по условие (тоест разполагаме с всевъзможни валути).

### Решение:
Разглеждаме ориентиран граф, чиито **върхове са валутите**. Между всеки два върха има по едно ребро в двете посоки. **Теглата на ребрата са валутните курсове**. По-точно, тегло w на реброто от валута X към валута Y означава, че можем да продадем една единица от X и срещу нея да получим w единици от Y.  
  
При движение по графа теглата на ребрата се умножават: ако сме заменили една единица от X за w1 единици от Y, а всяка от тях - за w2 единици от Z, в крайна сметка за една единица от X сме получили w_1 * w_2 единици от Z. Теглата са положителни реални числа - цели или дробни. Те могат да бъдат както по-големи, така и по-малки от 1.  
  
**Търсим печеливш цикъл, тоест цикъл с тегло > 1.**  

Както в предишната задача, логаритмуваме валутните курсове (така заменяме умножението със събиране) и обръщаме знаците на логаритмите ( или избираме основа за логаритмуване между 0 и 1).    

Сега вече графът може да съдържа не само положителни тегла, но също отрицателни и нулеви тегла. Търсим цикъл с тегло < 0. Можем да използваме **алгоритъма на Белман-Форд или алгоритъма на Флойд-Уоршал**.
  
- Ако цикълът трябва да минава през определен връх S, пускаме алгоритъма на Белман-Форд от върха S. В алгоритъма има проверка специално за отрицателен цикъл през началния връх S. Избираме алгоритъма на Белман—Форд, защото е по-бърз от алгоритъма на Флойд-Уоршал.
- Ако търсим отрицателен цикъл където и да било в графа, използваме алгоритъма на Флойд-Уоршал, защото той е по-бърз от n-кратно изпълнение на алгоритъма на Белман-Форд.

---

### Задача 3 (Изпит):
Конструирайте ефикасен алгоритъм, който получава като вход неориентиран свързан тегловен граф G и някакво ребро e ∈ E и връща **дали съществува минимално покриващо дърво на G, което съдържа e**.

![alt_text](https://i.ibb.co/1T8FRhS/MST.jpg)

**Пример:**  
*Вход: 2 5, Изход: Истина*  
*Вход: 1 7, Изход: Лъжа*

### Решение:
Построяваме граф G' = (V, E'), където E' са всички ребра от E с тегла по-малки от w(e), където 'e' е реброто от входа. Това очевидно може да стане във време O(|V| + |E|). След това намираме свързаните компоненти на G' във време O(|V| + |E'|). Нека краищата на реброто 'e' са върхове u и v. Ако u и v са в различни свързани компоненти на G', връщаме ДА, в противен случай - връщаме НЕ. Коректността следва директно от МПД-теоремата. Сложността по време е O(|V| + |E|).
