# Database management system, DBMS
[DBMS](https://docs.google.com/document/d/1dewJRqBfTZ530a4nW3-tRI5Sv51ywZXFNvEgZHvRsMk/edit)  

# Долни граници
## Доказателство за долна граница чрез дърво за вземане на решения (decision tree), чрез "игра срещу противник" (adversary argument) и чрез редукция.

Нека Π е произволна изчислителна задача. **Долна граница върху сложността на Π** е всяка функция φ(n), такава че всеки алгоритъм, който решава Π, работи във време Ω(φ(n)). **Горна граница върху сложността на Π** е всяка функция ψ(n), такава че поне един алгоритъм, който решава Π, работи във време O(ψ(n)).

## Задачи

### Задача 1 (The Balance Puzzle):
Дадени са 9 номерирани предмета, да речем топки. Осем от тях имат едно и също тегло, а една топка е по-тежка. Нашата цел е да идентифицираме тежката топка, като използваме везни. Везните нямат стандартни теглилки, така че можем да правим единствено измервания от вида: някои топки на едното блюдо срещу други топки на другото блюдо, и да наблюдаваме резултата. Има точно три възможности за резултата: везната да се наклони наляво, везната да се наклони надясно или везната да остане балансирана.  

Докажете "добра" долна граница за броя измервания, които трябва да направим, за да намерим тежката топка.

### Решение:
Нека деветте топки са b_1, ..., b_9. Ще докажем долна граница **2 измервания** за намиране на тежката топка, използвайки дърво за вземане на решения.

![alt_text](https://i.ibb.co/LhyxG6b/The-balance-puzzle.png)

Доказателството за долна граница е следното: Схемата трябва да е такава, че да различи една възможност от общо девет, използвайки тернарно дърво на вземане на решение. Тернарно дърво с височина 1 има най-много три листа, така че не може да различава повече от три възможности. Това не ни върши работа за тази задача. Очевидно дървото трябва да има височина поне 2, за да има поне девет листа, с които да може да различава девет възможности. От този аргумент следва, че 2 е долна граница, но НЕ следва, че е достижима долна граница. В случая, тя е достижима, но това следва от показаната конкретна схема.

---

### Задача 2 (The Twelve-coin Puzzle):
Дадени са 12 номерирани монети. Измежду тях, 11 имат едно и също тегло, а другата — да я наречем "странната" монета — е или по лека, или по- тежка. Нашата задача е да идентифицираме "странната" монета, както и да определим дали е лека или тежка, използвайки везни като тези в горната задача. Монетите са различими на външен вид, примерно са номерирани c_1, ..., c_12.  

Докажете "добра" долна граница за броя измервания, които трябва да направим, за да намерим "странната" монета и нейната "странност".

### Решение:
Броят на възможностите е 24: два пъти броя на монетите. Нека i' означава “c_1 е тежка”, i'' означава “c_1 е лека”, ii' означава “c_2 е тежка”, ii'' означава “c_2 е лека”, и така нататък, xii' означава “c_12 е тежка” и xii'' означава “c_12 е лека”.

![alt_text](https://i.ibb.co/gvPrYL7/The-twelve-coin-puzzle.png)

Дотук доказахме, че **три измервания са достатъчни**.  

**Три измервания са необходими**. Тъй като искаме да различим една възможност от общо 24 възможности и всяко измерване има най-много три възможни изхода, долна граница за броя на измерванията е горна граница от log_3(24).

---

### Задача 3:
Дадени са n подаръци и n кутии. На всеки подарък пасва точно една кутия. Не са позволени сравнения между 2 подаръка или между 2 кутии. Позволени са само сранвния от вида:
- кутияX пасва точно на подаръкX;
- кутияX е голяма за подаръкX;
- кутияX е малка за подаръкX.

Докажете, че всеки алгоритъм, който открива съответствието между подаръци и кутии работи във време Ω(nlogn).

### Решение:
Пасването на подаръците с кутиите е биекция. Следователно свеждаме задачата до намиране на "правилната" биекция от множеството на подаръците към множеството на кутиите. Всички биекции са n!. Това са възможните изходи на нашия алгоритъм. Следователно дървото за вземане на решения има поне n! листа. Разклонеността е 3. Следователно височината на дървото е поне log_3(n), което е точно Ω(nlogn).

---
Доказани долни граници:
- **Търсене на стойност в сортиран масив** — Ω(logn);
- **Сортиране чрез директни сравнения** — Ω(nlogn);
- **Намиране на конкретна биекция** — Ω(nlogn);
- **Уникалност на елементи** — Ω(nlogn);
- **Най- близки елементи**  — Ω(nlogn);
- **Намиране на мода** — Ω(nlogn);
---

### Задача 4:
Задачата за разпознаване "Свързаност" се дефинира така: общият пример е неориентиран граф G = (V, E), а въпросът е дали G е свързан.  

Докажете, че всеки алгоритъм за Свързаност, който прави достъпи до графа само чрез задаване на въпроси от вида **“Има ли ребро между връх i и връх j?”**, задава поне n^2 въпроса, ако броят на върховете е 2n.

### Решение:
Има аргументация чрез противник. Противникът разбива множеството от върховете на две подмножества U и W, които наричаме дяловете, като ∣U∣ = ∣W∣ = n, и след това действа така: Получавайки запитване за върхове i и j, 
- ако i и j са в един и същи дял, противникът отговаря ДА,
- ако i и j са в различни дялове, противникът отговаря НЕ.

Съществуват точно n^2 двуелементни множества {x, y}, такива че x и y са от различни дялове. Ще покажем, че всеки алгоритъм AlgConn за тази задача трябва да запита за всяко от тях. Да допуснем противното: AlgConn е коректен алгоритъм за Свързаност и съществува x ∈ U и съществува y ∈ W, такива че AlgConn не е направил запитване за x и y.
- Ако AlgConn отговори ДА, то противникът конструира несвързан граф, в който U и W са клики и няма нито едно ребро между връх от U и връх от W. По този начин противникът опровергава AlgConn, тъй като всички отговори, които е давал, са консистентни с този граф, а графът не е свързан. 

- Ако AlgConn отговори НЕ, то противникът конструира свързан граф, в който U и W са клики и има ребро между x и y. По този начин противникът опровергава AlgConn, тъй като всички отговори, които е давал, са консистентни с този граф, а графът е свързан.

---

### Задача 5:
Докажете "добра" долна граница за намиране на втори по големина елемент в масив.

### Решение:
1. Наивният подход е първо да намерим най- големия елемент за n-1 стъпки, после да го премахнем и да намерим втория най- голям елемент за n-2 стъпки.  
Този алгоритъм извършва общо 2n-3 стъпки.

2. Първо намираме най- големия елемент (за n-1 стъпки). След това "провеждаме мини турнир" само от тези, които са загубили от най- големия. Това са точно logn елемента. За да намерим най- големия от тях (тоест втория най- голям за целия масив), извършваме точно logn-1 сравнения.  
Този алгоритъм извършва общо n-1 + logn-1 стъпки и това е точна долна граница за задачата "Втори по големина елемент".

![alt_text](https://i.ibb.co/S3NZnWR/Second-Largest.png)

---
Нека Π_1 и П_2 са изчислителни задачи.  
Грубо казано, от факта, че Π_1 се свежда до Π_2 правим два извода:
- Ако Π_1 е трудна задача (каквото и да значи това), то Π_2 също е трудна. Няма как някаква вътрешна, иманентна сложност да изчезне при редукцията;
- Ако Π_2 е лесна (каквото и точно да значи това), то Π_1 също е лесна. По същата причина: не може иманентната сложност да изчезне при редукцията.  

Важно е да знаем, че следните изводи **НЕ са верни**:
- Ако Π_1 е лека, то Π_2 също е лека. Такъв извод няма. Винаги можем да направим нещата произволно сложни.
- Ако Π_2 е трудна, то Π_1 също е трудна. Такъв извод няма. Причината отново е, че винаги можем да направим нещата сложни.
---

### Задача 6:
Докажете, че всеки алгоритъм, който връща броя на различните стойности в масив, работи за време Ω(nlogn).

### Решение:
Допускаме, че съществува алгоритъм uniqueElementsCount, който връща броя на уникалните елементи в масив и работи за време по- бързо от nlogn (например n).  
Тогава можем да направим следната редукция:
```c++
elementUniqueness(arr[1..n])
{
	res <- uniqueElementsCount(arr) // O(n)
	return res == n // O(n)
}
```

Намерихме алгоритъм, който решава elementUniqueness за време O(n). Но имаме долна граница Ω(nlogn). Противоречие.  
Следователно всеки алгоритъм, който връща броя на различните стойности в масив, работи за време Ω(nlogn).

---

### Задача 7:
Можем ли да построим пирамида, която има сложност O(1) за добавяне на елемент и O(1) за извличане на най- малък елемент?

### Решение:
Да допуснем, че можем.  
Тогава можем да направим следната редукция:
```c++
sort(arr[1..n])
{
	Създай масив heap[1..n]
	heap <- buildHeap(arr) // O(n) ( n*insert(arr[i]) )
	
	for i <- 1 to n // O(n) ( n*extractMin() )
		arr[i] <- heap.extractMin()
}
```

Намерихме алгоритъм, който решава задачата Сортиране за време O(n). Но имаме долна граница Ω(nlogn). Противоречие.

---

### Задача 8:
Даден е масив от точки <x,y>, x ∈ R, y ∈ R.  
Докажете, че всеки алгоритъм, който сортира точките по ъгъла, който сключва радиус-векторът с Ox, работи във време Ω(nlogn).

### Решение:
Допускаме, че съществува алгоритъм sortPoints, който сортира точки по ъгъла, който сключва радиус-векторът с Ox за време по- бързо от nlogn (например n).  
Тогава можем да направим следната редукция:
```c++
sort(arr[1..n])
{
	Създай масив от наредени двойки <x,y> Points[1..n]
	
	for i <- 1 to n // O(n)
		Points[i].x <- 5
		Points[i].y <- arr[i]

	sortPoints(Points) // O(n)
	
	for i <- 1 to n // O(n)
		arr[i] <- Points[i].y
}
```

Намерихме алгоритъм, който решава задачата Сортиране за време O(n). Но имаме долна граница Ω(nlogn). Противоречие.
