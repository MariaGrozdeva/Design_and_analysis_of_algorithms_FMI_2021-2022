# Алгоритмична неподатливост. NP-пълнота и NP-трудност.

**Дефиниция 1:** Казваме, че **алгоритъм X е ефикасен**, ако сложността по време на X е O(n^k) за някаква положителна константа k.  

**Дефиниция 2:** Казваме, че **изчислителна задача Π е неподатлива**, ако за нея не съществува ефикасен алгоритъм.  

**Дефиниция 3:** **Клас на сложност** (complexity class) е множество изчислителни задачи със сходна сложност.

---


# Клас на сложност P
Това са **задачите за разпознаване**, за които има ефикасен алгоритъм.

---

## Недетерминирана машина на Turing (НМТ)
НМТ означава, че на една наредена двойка от състояние и буква съответстват, в общия случай, няколко възможности (може и нула) за “еволюция” на машината, които са наредени тройки от ново състояние, нова буква и движение на главата.  

Как да интепретираме възможността машината да еволюира по няколко различни начина едновременно? Какво означава да има няколко нови състояния и изобщо няколко нови конфигурации? Една смислена интепретация е, че винаги, когато машината трябва да мине в k > 1 нови конфигурации, тя се “размножава”: тя изчезва, но се появяват k нови НМТ, всяка от които се оказва в точно една от тези k конфигурации. Всяко от тези копия “заживява свой живот” според δ (ф-я на прехода). Всички тези копия са в едно и също дискретно време, но са различни в смисъл, че всяко си има свое състояние и своя лента със собствена позиция на главата. Тогава тези копия съществуват и работят едновременно, така че въвеждаме паралелизъм.  

Как НМТ приема и отхвърля? Да видим какво означава такава неограничено размножаваща се машина да приеме или отхвърли входа. При нормалните, детерминирани машини е ясно: приемането е достигане на приемаща конфигурация, а отхвърлянето е достигане на отхвърляща конфигурация.  

**Приемане и отхвърляне от недетерминирана машина:**  
Нека M е НМТ и x е неин вход.
- M приема x <=> **поне едно нейно копие** достигне до приемаща конфигурация.
- M отхвърля x <=> **всички нейни копия** достигнат до отхвърляща конфигурация или катастрофират, без никое копие да е достигнало до приемаща конфигурация.

---

# Клас на сложност NP
**NP** е класът на задачите за разпознаване, които се решават в полиномиално време при всякакви входни данни от **недетерминирана** машина на Тюринг.  

Еквивалентно: **NP** е класът на задачите за разпознаване, за които съществува алгоритъм с полиномиална времева сложност при всякакви входни данни, проверяващ отговора ДА на задачата с помощта на допълнителен параметър, наречен сертификат, който зависи от входните данни на задачата и чиято дължина е полиномиална спрямо тяхната.

---

# P vs NP
1. Щом всяка задача от **P** е в **NP**, то **P ⊆ NP**.

2. Най-важният нерешен въпрос в теоретичната информатика е **дали NP ⊆ P**. Иначе казано, **дали P = NP**.  
Класът **P** се състои от лесните за решаване задачи, ако приемем, че “лесна за решаване задача” и “задача, за която има полиномиална МТ” са синоними. Класът **NP** се състои от лесните за проверяване задачи, предвид това, че за всеки Да-екземпляр на такава задача, някоя полиномиална НМТ може да провери сертификат за него в полиномиално време. Въпросът дали **P = NP** е въпросът **дали лесно за решаване е същото като лесно за проверяване**.

## Полиномиални редукции
**Дефиниция 4:** Нека A и B са алгоритмични задачи. **Полиномиална редукция** (бележим A ∝_p B) от задачата A към задачата B наричаме алгоритъм от следния вид:  
```c++
A (inputA: входни данни на задачата A)
	1) inputB <- Редукция на входа(inputA)
	2) outputB <- B(inputB)
	3) outputA <- Редукция на изхода(outputB)
	4) return outputA
```
---

# NP-пълнота
Нека Π е задача за разпознаване. Казваме, че Π е **NP-пълна**, ако:
- Π ∈ **NP**;
- За всяка задача Π' ∈ **NP** съществува полиномиална редукция от Π' към Π (Π' ∝_p Π).

# NP-трудност
Нека Π е задача за разпознаване. Казваме, че Π е **NP-трудна**, ако за всяка задача Π' ∈ **NP** съществува полиномиална редукция от Π' към Π (Π' ∝_p Π).

---

![alt_text](https://i.ibb.co/Cm5L0mh/P-vs-NP.png)

---

### Теорема:
Ако C е **NP-трудна** задача и C ∝_p D, то D също е **NP-трудна** задача.   

**Доказателство:**  
Щом C е **NP-трудна** задача, то ∀A ∈ **NP** : A ∝_p C. По условие C ∝_p D. Следователно ∀A ∈ **NP** : A ∝_p D. Затова D е **NP-трудна**.

---

## SAT (Satisfiability) и теоремата на Cook:
Екземпляр: КНФ φ.  
Въпрос: Дали φ е удовлетворима?  

**Теорема на Cook:** SAT е **NP-пълна**.  
Доказателство: https://en.wikipedia.org/wiki/Cook%E2%80%93Levin_theorem

## 2-SAT:
2-SAT е частен случай на SAT: всички клаузи са дизюнкции с два операнда.  

***Пример:*** (¬x ∨ y) ∧ (t ∨ x) ∧ (y ∨ t).  

Задачата 2-SAT ∈ **P**, тоест за нея съществува бърз (полиномиален) алгоритъм; основава се на търсене на компонентите на силна свързаност на подходящ граф.

## 3-SAT:
3-SAT е частен случай на SAT: всички клаузи са дизюнкции с три операнда.  

***Пример:*** (¬x ∨ y ∨ t) ∧ (t ∨ x ∨ ¬y).  

3-SAT е **NP-пълна**.  
**Доказателство:**  
1. 3-SAT е в класа **NP**.  

Тук сертификатът ни е булев вектор, съставен от последователните стойности на променливите. Минаваме линейно през φ, замествайки със символите от сертификата, и по този начин, чрез едно линейно по големината на φ обхождане проверяваме дали се получава стойност "истина".

2. 3-SAT е **NP-трудна**.  

Използваме по- горната теорема. Знаем, че SAT е **NP-трудна**.  
Тогава можем да направим следната полиномиална редукция:  
SAT ∝_p 3-SAT по следния начин:  

Нека φ = (x ∨ y ∨ ¬z ∨ t ∨ p) ∧ (...) ∧ ...
Търсим φ', която да е еквивалентна на φ, но в същото време да може да "се обработи" от 3-SAT. Построяваме φ' по следния начин:  
φ' = (x ∨ y ∨ A) ∧ (¬A ∨ ¬z ∨ B) ∧ (¬B ∨ t ∨ p) ∧ (...) ∧ ...

## Други основни NP-пълни задачи:
- **SubsetSum** (търсене на подмножество с даден сбор) е **NP-пълна** задача.
- **Partition** (разбиване на множество на две части с равни сборове) е **NP-пълна** задача.
- **Knapsack** (Задачата за раницата) е **NP-пълна**.

### Задачи върху графи от класа **NP**:
- **“Изоморфен подграф”** е **NP-пълна задача**.  
Вход: два графа G и H.  
Въпрос: G съдържа ли подграф, изоморфен на H?

- **“Изоморфни графи”** вероятно е **NP-междинна** задача.  
Вход: два графа G и H.  
Въпрос: Изоморфни ли са G и H?

- **Vertex Cover** е **NP-пълна задача**.  
Вход: Неориентиран граф G, естествено число k.  
Въпрос: Дали G има върхово покриване U, такова че |U| <= k?

- **Dominating Set** е **NP-пълна задача**.  
Вход: Неориентиран граф G, естествено число k.  
Въпрос: Дали G има доминиращо множество U, такова че |U| <= k?

- **Clique** е **NP-пълна задача**.  
Вход: Неориентиран граф G, естествено число k.  
Въпрос: Дали G има клика U, такава че |U| >= k?

- **Anticlique** (“Независимо множество”) е **NP-пълна** задача.

- **“Най -дълъг прост път”** е **NP-пълна** задача.

**Задачите “Ойлеров път” и “Ойлеров цикъл” са от класа P**.  
**Задачите “Хамилтонов път” и “Хамилтонов цикъл” са от класа NP**.

---

## Задачи

### Задача 1:
Докажете, че следната задача е **NP-пълна**:  
**Общ пример:** Множество от булеви променливи X = {x_1, ..., x_n} и множество дизюнктивни клаузи C = {c_1, ..., c_m} над X.  
**Въпрос:** Дали съществуват поне две различни удовлетворяващи валюации за C?

### Решение:
Тази задача е известна като **Double SAT**.

1. Double SAT е в класа **NP**.  
За целта трябва да предложим къс сертификат и бърз алгоритъм за проверка на отговор да.  
Първо сертификатът ни е първата валюация. Минаваме линейно през множеството от дизюнктивни клаузи C, замествайки със символите от сертификата, и по този начин, чрез едно линейно по големината на C обхождане проверяваме дали се получава стойност "истина". Повтаряме същото за втората валюация.

2. Double SAT е **NP-трудна**.  
За да покажем, че Double SAT е **NP-трудна**, ще направим редукция от 3-SAT (3-SAT ∝_p Double SAT).  

Нека е даден пример <X, C> на 3-SAT. Ще конструираме пример <X', C'> на Double SAT, такъв че C е удовлетворимо <=> C' има поне две удовлетворяващи валюации. За целта добавяме една нова булева променлива (която не е в X), да я наречем z, и правим следната клауза k = {z, ¬z}. После правим C' ← C ∪ k.  

Да допуснем, че C е удовлетворимо. Тогава C има поне една удовлетворяваща валюация **φ**. Щом **φ** е удовлетворяваща, във всяка клауза от C има поне един литерал **y**, такъв че **φ(y) = 1**.  
Конструираме две валюации **Ψ** и **Ψ'** така: рестрикцията на всяка от тях до домейна X е точно като **φ**, а **Ψ(z) = 0** и **Ψ'(z) = 1**. Очевидно **Ψ** и **Ψ'** са различни, имайки различни стойности върху z.  

Ще покажем, че във всяка клауза на c ∈ C' има поне един литерал, който има стойност 1 както под **Ψ**, така и под **Ψ'** :
- ако c ∈ C, това следва от фактите, че **φ** е удовлетворима за C и, че **Ψ** и **Ψ'** върху променливите от X съвпадат със съответните стойности на **φ**;
- ако c = {z, ¬z}, то **Ψ(¬z) = 1** и **Ψ'(z) = 1**.

Сега да допуснем, че C' е удовлетворима от поне две различни удовлетворяващи валюации **Ψ** и **Ψ'**. Тогава и под **Ψ**, и под **Ψ'** е вярно, че за всяка клауза на C' има литерал, чиято стойност е 1, което веднага влече, че рестрикцията на коя да е от тях върху домейн X е удовлетворяваща валюация за C.

---

### Задача 2:
Докажете, че следната задача е **NP-пълна**:  
**Общ пример:** Множество A, множество B ⊆ 2^A, число k ∈ N.  
**Въпрос:** Съществува ли C ⊆ B, такова че |C| ≤ k и ∪C = A?

### Решение:
Тази задача е известна като **Set Cover**.

1. Set Cover е в класа **NP**.
Сертификатът ни е множеството C. Лесно можем да проверим (симулирайки чрез сертификата детерминирана машина на Тюринг), че |C| ≤ k и ∪C = A.

2. Set Cover е **NP-трудна**.
За да покажем, че Set Cover е **NP-трудна**, ще направим редукция от Vertex Cover (Vertex Cover ∝_p Set Cover).  

Нека е даден произволен пример на Vertex Cover. Този пример е наредена двойка (G = (V, E), k'), където G е граф, а k' - естествено число. Ще построим пример (A, B, k) на Set Cover.  
Първо, k <- k' . Второ, A <- E. Трето, B се състои от |V| на брой елемента B = {B_1, B_2, ..., B_|V|}, като всяко B_i съответства на точно един връх v_i от графа. Нещо повече, B_i е множеството от точно тези ребра от E, които са инцидентни с v_i .  
- Фактът, че (G = (V, E), k') е ДА-пример на Vertex Cover тогава и само тогава, когато (A, B, k) е ДА-пример на Set Cover, вземаме за очевиден.
- Фактът, че конструкцията може да се направи в полиномиално време, е очевиден. Така че действително тук описахме полиномиална редукция.

### Задача 3:
Докажете, че следната задача е **NP-пълна**:  
**Общ пример:** Неориентиран свързан граф G и естествено число k.  
**Въпрос:** Съществува ли покриващо дърво T на G, т. че максималната степен на връх в T е не по-голяма от k?

### Решение:
Принадлежността към **NP** е очевидна.  
Задачата е **NP-трудна**.  Има тривиална редукция от Хамилтонов път: при k = 2 покриващото дърво е Хамилтонов път.
